---
title: 常用排序算法的比较
mathjax: true
date: 2021-04-09 21:39:31
updated: 2021-04-09 21:39:31
categories:
- Algorithm
tags:
- 面试
- 排序
---

记录一下各种常见排序算法的比较。

<!--more-->

|     名称     |                             思想                             | 最好时间复杂度 | 最坏时间复杂度 | 平均时间复杂度 | 空间复杂度 | 是否稳定 |
| :----------: | :----------------------------------------------------------: | :------------: | :------------: | -------------- | :--------: | :------: |
|   冒泡排序   | 两两比较相邻记录的关键字，如果反序则交换，直到没有反序的记录为止 |     $O(n)$     |    $O(n^2)$    | $O(n^2)$       |   $O(1)$   |    是    |
|   插入排序   | 把$n$个待排序的元素看成为一个有序表和一个无序表。开始时有序表中只包含1个元素，无序表中包含有$n-1$个元素，排序过程中每次从无序表中取出第一个元素，将它插入到有序表中的适当位置，使之成为新的有序表，重复$n-1$次可完成排序过程 |     $O(n)$     |    $O(n^2)$    | $O(n^2)$       |   $O(1)$   |    是    |
| 简单选择排序 | 通过$n-i$次关键字之间的比较，从$n-i+1$个记录中选择关键字最小的记录，并和第$i(1 \le i \le n)$个记录交换之 |    $O(n^2)$    |    $O(n^2)$    | $O(n^2)$       |   $O(1)$   |    否    |
|   归并排序   | 分治算法，是建立在归并操作上的一种有效的排序算法。常用的2路归并排序假设初始序列有$n$个记录，可以看成是$n$个长度为1的子序列，进行两两归并，可以得到$\frac{n}{2}$个长度为2的子序列；再两两归并,直到得到一个长度为$n$的有序序列为止 |   $O(nlogn)$   |   $O(nlogn)$   | $O(nlogn)$     |   $O(n)$   |    是    |
|    堆排序    | 把待排序的序列构造成一个大顶堆，此时序列的最大值就是队顶元素，把该元素放在最后，然后对剩下的$n-1$个元素继续构造大顶堆，直到排序完成 |   $O(nlogn)$   |   $O(nlogn)$   | $O(nlogn)$     |   $O(1)$   |    否    |
|   快速排序   | 通过一趟排序将待排记录分割成独立的两部分，其中一部分的记录都比另一部分小，然后再分别对这两个部分进行快速排序，最终实现整个序列的排序 |   $O(nlogn)$   |    $O(n^2)$    | $O(nlogn)$     | $O(logn)$  |    否    |

